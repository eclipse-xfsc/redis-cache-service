// Code generated by goa v3.20.1, DO NOT EDIT.
//
// cache HTTP client CLI support package
//
// Command:
// $ goa gen github.com/eclipse-xfsc/redis-cache-service/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	cache "github.com/eclipse-xfsc/redis-cache-service/gen/cache"
)

// BuildGetPayload builds the payload for the cache Get endpoint from CLI flags.
func BuildGetPayload(cacheGetKey string, cacheGetNamespace string, cacheGetScope string, cacheGetStrategy string) (*cache.CacheGetRequest, error) {
	var key string
	{
		key = cacheGetKey
	}
	var namespace *string
	{
		if cacheGetNamespace != "" {
			namespace = &cacheGetNamespace
		}
	}
	var scope *string
	{
		if cacheGetScope != "" {
			scope = &cacheGetScope
		}
	}
	var strategy *string
	{
		if cacheGetStrategy != "" {
			strategy = &cacheGetStrategy
		}
	}
	v := &cache.CacheGetRequest{}
	v.Key = key
	v.Namespace = namespace
	v.Scope = scope
	v.Strategy = strategy

	return v, nil
}

// BuildSetPayload builds the payload for the cache Set endpoint from CLI flags.
func BuildSetPayload(cacheSetBody string, cacheSetKey string, cacheSetNamespace string, cacheSetScope string, cacheSetTTL string) (*cache.CacheSetRequest, error) {
	var err error
	var body any
	{
		err = json.Unmarshal([]byte(cacheSetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "\"Enim vel.\"")
		}
	}
	var key string
	{
		key = cacheSetKey
	}
	var namespace *string
	{
		if cacheSetNamespace != "" {
			namespace = &cacheSetNamespace
		}
	}
	var scope *string
	{
		if cacheSetScope != "" {
			scope = &cacheSetScope
		}
	}
	var ttl *int
	{
		if cacheSetTTL != "" {
			var v int64
			v, err = strconv.ParseInt(cacheSetTTL, 10, strconv.IntSize)
			val := int(v)
			ttl = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for ttl, must be INT")
			}
		}
	}
	v := body
	res := &cache.CacheSetRequest{
		Data: v,
	}
	res.Key = key
	res.Namespace = namespace
	res.Scope = scope
	res.TTL = ttl

	return res, nil
}

// BuildSetExternalPayload builds the payload for the cache SetExternal
// endpoint from CLI flags.
func BuildSetExternalPayload(cacheSetExternalBody string, cacheSetExternalKey string, cacheSetExternalNamespace string, cacheSetExternalScope string, cacheSetExternalTTL string) (*cache.CacheSetRequest, error) {
	var err error
	var body any
	{
		err = json.Unmarshal([]byte(cacheSetExternalBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "\"Sint ipsa fugiat et id rem.\"")
		}
	}
	var key string
	{
		key = cacheSetExternalKey
	}
	var namespace *string
	{
		if cacheSetExternalNamespace != "" {
			namespace = &cacheSetExternalNamespace
		}
	}
	var scope *string
	{
		if cacheSetExternalScope != "" {
			scope = &cacheSetExternalScope
		}
	}
	var ttl *int
	{
		if cacheSetExternalTTL != "" {
			var v int64
			v, err = strconv.ParseInt(cacheSetExternalTTL, 10, strconv.IntSize)
			val := int(v)
			ttl = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for ttl, must be INT")
			}
		}
	}
	v := body
	res := &cache.CacheSetRequest{
		Data: v,
	}
	res.Key = key
	res.Namespace = namespace
	res.Scope = scope
	res.TTL = ttl

	return res, nil
}
